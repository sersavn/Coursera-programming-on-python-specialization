1. Системный вызов fork

F - используется для вызова функций в отдельных потоках
F - используется для получения pid родительского процесса
T - используется для создания дочернего процесса
T - создает точную копию родительского процесса

2. Системный вызов fork

F - в дочернем процессе вызов fork возвращает pid родительского процесса
T - в дочернем процессе вызов fork возвращает 0
F - в родительском процессе вызов fork возвращает 0
T - в родительском процессе вызов fork возвращает pid дочернего

3. Что происходит с памятью в дочернем процессе при работе с Python?

T - Копируется из родительского процесса
F - Разделяется с родительским процессом

4. Файловые дескрипторы в дочернем процессе

F - будут переоткрыты Python интерпретатором автоматически
F - будут скопированы и переоткрыты
F - будут недоступны, их нужно переоткрыть заново
T - будут скопированы

5. Выделить истинные выражения:

F - блокировки нужно брать в одном порядке, освобождать строго в том же порядке
F - блокировки нужно брать в одном порядке, освобождать в произвольном
T - блокировки нужно брать в одном порядке, освобождать в обратном
T - предпочтительнее использовать контекстный менеджер для работы с блокировками в Python

6. Очереди замедляют процесс работы потоков Python, лучше использовать объекты блокировки

F - Да
T - Нет

7. Выделить истинные выражения:

T - GIL запрещает одновременное выполнение инструкций байткода в разных потоках
T - GIL никак не влияет на выполнение отдельных процессов на Python3
F - GIL замедляет выполнение главного потока управления в Python3, даже если нет других потоков
T - GIL нужен для защиты памяти интерпретатора от разрушений

8. Если программа на Python выполняет много операций ввода вывода (IO-bound), то для ускорения ее работы нужно

F - создать отдельные процессы
T - разбить ее на отдельные функции, выполнить их в потоках

9. Если программа на Python выполняет операции вычисления, требующие только CPU (CPU-bound), то для ускорения ее работы нужно

F - разбить ее на отдельные функции, выполнить их в потоках
T - создать отдельные процессы

10. Генератор в Python – это

F - инструкция yield
F - объект типа concurrent.futures.Future
F - специальный вызов yield from
T - функция в которой присутствует инструкция yield

11. Отметить все истинные утверждения:

F - итератор прерывает свое выполнение на каждой итерации, сохраняя состояние локальных переменных
T - генератор хранит значение для генерации следующего элемента последовательности в локальных переменных
T - итератор хранит значение для генерации следующего элемента последовательности в self
T - исключение StopIteration используется для остановки работы итератора

12. Отметить все истинные утверждения: False

F - сопрограмма может прерывать свою работу, сохраняя свое состояние и значения всех локальных переменных
F - исключения нельзя обрабатывать в сопрограммах, это нужно делать в основном потоке
T - из одной сопрограммы можно вызвать другую при помощи yield from
T - сопрограммы исполняются в отдельных потоках параллельно

13. Отметить все истинные утверждения, касающиеся asyncio event loop: F

T - позволяет выполнять корутины, зарегистрированные в нем
F - выполняет несколько корутин параллельно в разных потоках
F - отвечает за выделение памяти в основном процессе
F - переключает контекст между Python-потоками
F - позволяет выполнять функции и callable Python объекты
T - выполняет все корутины последовательно, переключая контекст между ними

14. Отметить все истинные утверждения:

T - объект типа asyncio.Task хранит в себе связанную корутину и содержит статус ее выполнения
F - блокирующий код в Python никак не повлияет на выполнение других корутин в asyncio event loop
T - из объектов типа asyncio.Future можно создавать цепочки и дожидаться их выполнения в asyncio event loop
F - объект типа asyncio.Task выполняется в отдельном потоке управления, никак не влияя на выполнения других объектов типа asyncio.Task