1. Для чего необходимы утверждения assert в языке программирования? F

F - Для отслеживания ошибок ввода.
F - Для передачи сообщений между частями программы.
T - Для отслеживания контрактов функций, проверки инвариантов и контроля за недопустимыми состояниями объектов.

2. Можно ли перехватывать исключение AssertionError?

F - Нельзя. Это не предусмотрено языком программирования.
F - Можно. Так же, как и любое другое исключение, его следует перехватывать и обрабатывать.
T - Можно, но никогда не следует этого делать.

3. Корректно ли такое использование утверждения? 

```
x = int(input("Enter positive number, please: "))
assert x > 0, "Value should be positive!"
```
F - Да
T - Нет #dont use asserion on input

4. Какой способ описания контракта правильный?

(При использовании библиотеки PyContracts)

```
@contract(x='float', returns='float,>=0')
def foo(x):
    pass

@contract
def foo(x):
    """ Function with contract.
        :type x: float
        :rtype: float,>=0
    """
    pass

@contract
def foo(x:'float') -> 'float,>=0':
    pass
```

T - Подходит любой вариант из описанных выше.


5. Дана функция, вычисляющая наибольший общий делитель при помощи алгоритма Евклида.
Сделайте проверку входных параметров функции при помощи assert. 
Оба параметра должны быть положительными целыми числами. F

```
def gcd(a, b):
    assert (type(a) == int and type(b) == int and a > 0 and b > 0)
    r = a % b
    b = a
    a = r
  return a
```

6. Новый контракт при использовании библиотеки PyContracts: F

Описывается как класс, являющийся наследником класса BaseContract.
F - Описывается как класс, который нужно передать функции new_contract.
T - Описывается как функция или строка, которую нужно передать в качестве параметра функции new_contract, либо использовать new_contract как декоратор.
Способа создать новый контракт в библиотеке PyContracts нет.

7. Какое предусловие выдвигает данный контракт к входному параметру x?

```
@contract
def foo(x:'list[>0]((float|int),>=1,<=1000)'):
    pass
```


T - Параметр x должен быть непустым списком, состоящим из чисел в диапазоне от 1 до 1000. 
Числа могут быть целыми или дробными.

F - Параметр x должен быть непустым списком, содержащим положительные целые или дробные числа. 
При этом длина списка не должна превышать 1000.

F - Параметр x должен быть либо непустым списком, либо целым или дробным числом. 
В последнем случае число должно быть в диапазоне от 1 до 1000.

8. Какое предусловие выдвигает данный контракт к входному параметру y?
```
@contract
def foo(y: 'set[>0]((int,>0)|(float,<0))'):
    pass
```
T - Параметр y должен быть непустым множеством, состоящим из положительных целых и отрицательных дробных чисел.
F - Параметр y должен быть непустым множеством, состоящим либо из положительных целых, 
либо из отрицательных дробных (не одновременно).
F- Параметр y должен быть непустым множеством, содержащим положительные или отрицательные числа. 
Допустимые типы чисел — целые и дробные.

9. Какое предусловие выдвигает данный контракт к входному параметру z?

T - Параметр z должен быть либо словарём с ключами из целых чисел, либо словарём с ключами из дробных чисел. 
Требований на тип хранимого по ключу значения не накладывается.

F - Параметр z должен быть словарём с числовым ключом. Числа допустимы как целые, так и дробные. 
Требований на тип хранимого по ключу значения не накладывается.